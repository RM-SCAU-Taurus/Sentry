#include "chassis_task.h"
#include "cmsis_os.h"
#include "comm_task.h"
#include "string.h"
#include "pid.h"
#include "stdlib.h"
#include "bsp_can.h"
#include "bsp_powerlimit.h"
#include "math_calcu.h"
#include "math.h"
#include "remote_msg.h"
#include "modeswitch_task.h"
#include "status_task.h"
#include "control_def.h"
extern TaskHandle_t can_msg_send_task_t;

chassis_t chassis;
chassis_control_msg_t chassis_control_msg={0};
/**
	* @brief      底盘任务初始化
	* @author         
	* @param[in]  
	* @retval     
	*/
void chassis_param_init(void)
{
	PowerControl_Init();
	for(int i=0; i<4; i++)
	{
		PID_struct_init(&pid_chassis_3508_spd[i], POSITION_PID, 13000, 0,
									  7.0f, 0.0f, 0.0f);

		PID_struct_init(&pid_chassis_6020_ecd[i], POSITION_PID, 120, 100,
										0.5f, 0.0f, 0.0f);
		PID_struct_init(&pid_chassis_6020_spd[i], POSITION_PID, 28000, 25000,
										168.0f, 1.0f, 0.0f);
	}
	chassis.rudder_ecd_offset[0] = 7633;
	chassis.rudder_ecd_offset[1] = 5624;
	chassis.rudder_ecd_offset[2] = 3592;
	chassis.rudder_ecd_offset[3] = 226;
}

/**
  * @brief 底盘姿态任务
  * @param     
  * @attention  
	* @note  
  */
void chassis_task(void const *argu)
{
	uint32_t mode_wake_time = osKernelSysTick();
	for(;;)
	{
		taskENTER_CRITICAL();
		switch(ctrl_mode)
		{
			case PROTECT_MODE:
			{
				memset(chassis.current_3508, 0, sizeof(chassis.current_3508));
				memset(chassis.current_6020, 0, sizeof(chassis.current_6020));
				for(uint8_t i=0;i<4;i++)
				{
					pid_chassis_6020_spd[i].iout=0;
				}
				supercap.mode = 0;
				supercap.charge_current_set = 0;
				break;
			}
			case REMOTER_MODE:
			{
			  chassis.spd_input.vx=rc.ch4*rc_ch4_scale*2;
				chassis.spd_input.vy=rc.ch3*rc_ch3_scale*2;
				chassis.spd_input.vw= -1.0f * rc.ch1 * rc_ch1_scale*1.5f;
				steering_calc(chassis.spd_input.vx, chassis.spd_input.vy, chassis.spd_input.vw, chassis.rudder_angle_ref, chassis.wheel_spd_input);
				/* 底盘速度超限重分配 */
				chassis_spd_distribution();
				/* PID计算电机控制电流 */
				chassis_pid_calcu();
				
				/* 转舵保护 */
				for(uint8_t i=0;i<4;i++)
				{
					if(ABS(chassis.rudder_ecd_error[i])>2048)
					{
						memset(chassis.current_3508, 0, sizeof(chassis.current_3508));
					}
				}
			  break;
			}
			default:
			{
				/* 舵轮解算 */
					steering_calc(chassis.spd_input.vx, chassis.spd_input.vy, chassis.spd_input.vw, chassis.rudder_angle_ref, chassis.wheel_spd_input);
				/* 底盘速度超限重分配 */
				chassis_spd_distribution();
				/* PID计算电机控制电流 */
				chassis_pid_calcu();
				/* 功率/电容控制 */
				Power_Data_Update();
				SuperCap_Control();
				Power_Control(chassis.current_3508, chassis.current_6020);
				
				/* 转舵保护 */
				for(uint8_t i=0;i<4;i++)
				{
					if(ABS(chassis.rudder_ecd_error[i])>2048)
					{
						memset(chassis.current_3508, 0, sizeof(chassis.current_3508));
					}
				}
				break;
			}
		}

		memcpy(motor_cur.chassis_cur_3508, chassis.current_3508, sizeof(chassis.current_3508));
		memcpy(motor_cur.chassis_cur_6020, chassis.current_6020, sizeof(chassis.current_6020));

		osSignalSet(can_msg_send_task_t, CHASSIS_MOTOR_MSG_SEND);

		taskEXIT_CRITICAL();

		osDelayUntil(&mode_wake_time, CHASSIS_PERIOD);
	}
}

/**
  * @brief 麦轮解算函数
  * @param input : ?=+vx(mm/s)  ?=+vy(mm/s)  ccw=+vw(deg/s)
  *        output: every wheel speed(rpm)
  * @note  1=FL 2=FR 3=BL 4=BR
  */
void mecanum_calc(float vx, float vy, float vw, float speed[])
{
  float wheel_rpm[4];

	wheel_rpm[0] =    vx + vy - vw;		
	wheel_rpm[1] = 	 -vx + vy - vw; 	
	wheel_rpm[2] =    vx - vy - vw;		
	wheel_rpm[3] =   -vx - vy - vw;

	memcpy(speed, wheel_rpm, 4*sizeof(float));
}



/**
  * @brief 舵轮解算函数
  * @param input : ?=+vx(mm/s)  ?=+vy(mm/s)  ccw=+vw(deg/s)
  *        output: every wheel speed(rpm) and angle(°)
  * @note  0=FL 1=BL 2=FR 3=BR
  */
void steering_calc(float vx, float vy, float vw, float angle[], float speed[])
{
	float wheel_rpm[4];
	float	rudder_angle[4];
	const float rudder_deadband = 100;

	/* 轮速解算 */
	wheel_rpm[0] = sqrt(pow(vx,2) + pow(vy,2) + pow(vw,2) - 2*vw*(vx+vy));
	wheel_rpm[1] = sqrt(pow(vx,2) + pow(vy,2) + pow(vw,2) - 2*vw*(vx-vy));
	wheel_rpm[2] = -1.0f * sqrt(pow(vx,2) + pow(vy,2) + pow(vw,2) + 2*vw*(vx-vy));
	wheel_rpm[3] = -1.0f * sqrt(pow(vx,2) + pow(vy,2) + pow(vw,2) + 2*vw*(vx+vy));

	/* 舵角解算 */
	rudder_angle[0] = atan2((vy-vw), (vx-vw)) * 57.296f;
	rudder_angle[1] = atan2((vy+vw), (vx-vw)) * 57.296f;
	rudder_angle[2] = atan2((vy-vw), (vx+vw)) * 57.296f;
	rudder_angle[3] = atan2((vy+vw), (vx+vw)) * 57.296f;
	
  switch(chassis.mode)
	{
		case 0x01:
  { 
		if(ABS(chassis.spd_input.vx)>rudder_deadband || ABS(chassis.spd_input.vy)>rudder_deadband || ABS(chassis.spd_input.vw)>rudder_deadband)
	{
		memcpy(speed, wheel_rpm, 4*sizeof(float));
		memcpy(angle, rudder_angle, 4*sizeof(float));
	}
	else
	{
		memset(speed, 0, 4*sizeof(float));
		memset(angle, 0, 4*sizeof(float));
	}
	break;
 }
	  case 0x02:
		{
      memcpy(speed, wheel_rpm, 4*sizeof(float));
		  memcpy(angle, rudder_angle, 4*sizeof(float));
			break;
		}	
	}
}

/**
	* @brief	底盘速度分配函数，输入总速度超过总最大轮速时，将输入的速度按比例重分配
	* @author
	* @param[in]
	* @retval
	*/
void chassis_spd_distribution(void)
{
//	float	wheel_spd_input_buf[4];
//	float wheel_spd_total = 0;			//总轮速
//	float	distribution_temp = 1.0f; //限制比例


//	/* 计算总轮速 */
//	for(uint8_t i=0; i<4; i++)
//	{
//		wheel_spd_input_buf[i] = ABS(chassis.wheel_spd_input[i]);
//		wheel_spd_total += wheel_spd_input_buf[i];
//	}

//	/* 如果总轮速超限则要计算超限比例 */
//	if(wheel_spd_total > (chassis.wheel_max * 4.0f))
//		distribution_temp = wheel_spd_total / (chassis.wheel_max * 4.0f);

//	/* 速度重分配 */
//	for(uint8_t j=0; j<4; j++)
//	{
//		chassis.wheel_spd_ref[j] = chassis.wheel_spd_input[j] / distribution_temp;
//		chassis.wheel_spd_ref[j] = data_limit(chassis.wheel_spd_ref[j], 8680, -8680);
//	}
		float  wheel_spd_input_buf[4];
    float  distribution_temp = 1.0f;//限制比例

    for(uint8_t i = 0; i < 4; ++i) {
        wheel_spd_input_buf[i] = ABS(chassis.wheel_spd_input[i]);
    }
    Bubble_Sort(wheel_spd_input_buf, 4);  /* 将轮速绝对值从大到小排序 */
    if (wheel_spd_input_buf[0] > chassis.wheel_max) {  /* 计算分配比例 */
        distribution_temp = chassis.wheel_max / wheel_spd_input_buf[0];
    }
    /* 速度重分配 */
    for(uint8_t j = 0; j < 4; ++j) {
        chassis.wheel_spd_ref[j] = chassis.wheel_spd_input[j] * distribution_temp;
    }
}

/**
  * @brief      底盘PID
  * @author         
  * @param[in]  
  * @retval     
  */
void chassis_pid_calcu(void)
{
	for(uint8_t i=0; i<4; i++)
	{
		/* 底盘电机速度环 */
		chassis.wheel_spd_fdb[i] = moto_msg.chassis_3508[i].speed_rpm;
		chassis.current_3508[i]  = (int16_t)pid_calc(&pid_chassis_3508_spd[i], chassis.wheel_spd_fdb[i], chassis.wheel_spd_ref[i]);

		/* 舵6020位置串级闭环 */
		chassis.rudder_ecd_ref[i] = (chassis.rudder_angle_ref[i]*22.753f) + chassis.rudder_ecd_offset[i];
		if(chassis.rudder_ecd_ref[i] >= 8191)
			chassis.rudder_ecd_ref[i] -= 8191;
		else if(chassis.rudder_ecd_ref[i] < 0)
			chassis.rudder_ecd_ref[i] += 8191;
		
		/* 舵角斜坡输入 */
		//chassis.rudder_ecd_ref_ramp[i] =
		chassis.rudder_ecd_fdb[i]   = moto_msg.chassis_6020[i].ecd;
		chassis.rudder_ecd_error[i] = circle_error(&chassis.rudder_ecd_ref[i], &chassis.rudder_ecd_fdb[i], 8191);
		/*位置环*/
		pid_calc(&pid_chassis_6020_ecd[i], chassis.rudder_ecd_fdb[i], (chassis.rudder_ecd_fdb[i]+chassis.rudder_ecd_error[i]));

		chassis.rudder_spd_ref[i] = pid_chassis_6020_ecd[i].pos_out;
		chassis.rudder_spd_fdb[i] = moto_msg.chassis_6020[i].speed_rpm;
		/*速度环*/
		chassis.current_6020[i] = (int16_t)pid_calc(&pid_chassis_6020_spd[i], chassis.rudder_spd_fdb[i], chassis.rudder_spd_ref[i]);
	}
}

